<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Game Editor Touch FIXED</title>

<style>
body{
  margin:0;
  display:flex;
  height:100vh;
  background:#222;
  color:#fff;
  font-family:sans-serif;
}
#canvasWrap{
  flex:1;
  display:flex;
  justify-content:center;
  align-items:center;
  background:#000;
}
canvas{
  background:#555;
  touch-action:none;
}

#panel{
  width:420px;
  padding:10px;
  background:#333;
  overflow:auto;
}

.layer-item{
  background:#444;
  padding:4px;
  margin-bottom:4px;
  font-size:11px;
  cursor:pointer;
}
.layer-item.active{ background:#666; }

label{ font-size:12px; display:block; margin-top:6px; }
input,button{ width:100%; }

#logBox{
  background:#111;
  font-size:11px;
  padding:6px;
  white-space:pre-wrap;
  max-height:200px;
  overflow:auto;
}
</style>
</head>

<body>

<div id="canvasWrap">
  <canvas id="canvas"></canvas>
</div>

<div id="panel">
  <label>画像追加 <input type="file" id="imgInput"></label>

  <div id="layerList"></div>

  <h3>数値調整</h3>
  <label>X <input type="number" id="xI"></label>
  <label>Y <input type="number" id="yI"></label>
  <label>Scale <input type="number" step="0.01" id="sI"></label>
  <label>Rotate <input type="number" id="rI"></label>
  <label>Float（0〜10） <input type="number" min="0" max="10" id="fI"></label>
  <label>Speed（1〜10） <input type="number" min="1" max="10" id="spI"></label>

  <button id="snapshotBtn">スナップショット保存</button>
  <div id="logBox"></div>
</div>

<script>
/* ===== 基本 ===== */
const BASE_W=1280, BASE_H=720;
const FLOAT_PX=4, SPEED_UNIT=0.8;

const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

/* ===== resize ===== */
function resize(){
  const wrap=document.getElementById("canvasWrap");
  const r=wrap.getBoundingClientRect();
  const sc=Math.min(r.width/BASE_W,r.height/BASE_H);
  canvas.width=BASE_W*sc;
  canvas.height=BASE_H*sc;
  ctx.setTransform(sc,0,0,sc,0,0);
}
window.addEventListener("resize",resize);
resize();

/* ===== データ ===== */
let layers=[], current=null;

/* ===== UI ===== */
const listEl=document.getElementById("layerList");
const xI=document.getElementById("xI");
const yI=document.getElementById("yI");
const sI=document.getElementById("sI");
const rI=document.getElementById("rI");
const fI=document.getElementById("fI");
const spI=document.getElementById("spI");
const logBox=document.getElementById("logBox");

/* ===== 画像追加 ===== */
imgInput.onchange=e=>{
  const f=e.target.files[0];
  const img=new Image();
  img.onload=()=>{
    const l={name:f.name,img,x:BASE_W/2,y:BASE_H/2,scale:1,rotate:0,float:0,speed:5};
    layers.unshift(l);
    current=l;
    refreshUI();
  };
  img.src=URL.createObjectURL(f);
};

/* ===== レイヤーUI ===== */
function refreshUI(){
  listEl.innerHTML="";
  layers.forEach((l,i)=>{
    const d=document.createElement("div");
    d.className="layer-item"+(l===current?" active":"");
    d.textContent=`${i+1} ${l.name}`;
    d.onclick=()=>{current=l; refreshUI();};
    listEl.appendChild(d);
  });
  if(current){
    xI.value=current.x;
    yI.value=current.y;
    sI.value=current.scale;
    rI.value=current.rotate;
    fI.value=current.float;
    spI.value=current.speed;
  }
}

/* ===== 数値反映 ===== */
[xI,yI,sI,rI,fI,spI].forEach(inp=>{
  inp.oninput=()=>{
    if(!current) return;
    current.x=+xI.value;
    current.y=+yI.value;
    current.scale=+sI.value;
    current.rotate=+rI.value;
    current.float=+fI.value;
    current.speed=+spI.value;
  };
});

/* ===== 正確タッチ（canvas直結） ===== */
let pointers=new Map();
let gesture=null;

canvas.addEventListener("pointerdown",e=>{
  canvas.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(pointers.size===2 && current){
    const p=[...pointers.values()];
    const dx=p[1].x-p[0].x;
    const dy=p[1].y-p[0].y;
    gesture={
      dist:Math.hypot(dx,dy),
      angle:Math.atan2(dy,dx),
      scale:current.scale,
      rotate:current.rotate
    };
  }
});

canvas.addEventListener("pointerup",e=>{
  pointers.delete(e.pointerId);
  if(pointers.size<2) gesture=null;
});
canvas.addEventListener("pointercancel",e=>{
  pointers.delete(e.pointerId);
  gesture=null;
});

canvas.addEventListener("pointermove",e=>{
  if(!current||!pointers.has(e.pointerId)) return;
  const prev=pointers.get(e.pointerId);
  pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});

  const rect=canvas.getBoundingClientRect();

  if(pointers.size===1){
    current.x+=(e.clientX-prev.x)*BASE_W/rect.width;
    current.y+=(e.clientY-prev.y)*BASE_H/rect.height;
  }

  if(pointers.size===2 && gesture){
    const p=[...pointers.values()];
    const dx=p[1].x-p[0].x;
    const dy=p[1].y-p[0].y;
    const dist=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx);

    current.scale=gesture.scale*(dist/gesture.dist);
    current.rotate=gesture.rotate+(ang-gesture.angle)*180/Math.PI;
  }
});

/* ===== 描画 ===== */
let start=performance.now();
function draw(){
  const t=(performance.now()-start)/1000;
  ctx.setTransform(ctx.getTransform()); // 念のため維持
  ctx.fillStyle="#555";
  ctx.fillRect(0,0,BASE_W,BASE_H);

  layers.slice().reverse().forEach(l=>{
    if(!l.img.complete) return;
    const fy=Math.sin(t*l.speed*SPEED_UNIT)*l.float*FLOAT_PX;
    ctx.save();
    ctx.translate(l.x,l.y+fy);
    ctx.rotate(l.rotate*Math.PI/180);
    ctx.scale(l.scale,l.scale);
    ctx.drawImage(l.img,-l.img.width/2,-l.img.height/2);
    ctx.restore();
  });
  requestAnimationFrame(draw);
}
draw();

/* ===== ログ ===== */
snapshotBtn.onclick=()=>{
  let txt="SNAPSHOT\n";
  layers.forEach((l,i)=>{
    txt+=`${i+1} ${l.name} x:${l.x} y:${l.y} s:${l.scale} r:${l.rotate} f:${l.float} sp:${l.speed}\n`;
  });
  logBox.prepend(Object.assign(document.createElement("div"),{textContent:txt}));
};
</script>

</body>
</html>
