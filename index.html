<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Canvas Editor FINAL STABLE</title>

<style>
body{
  margin:0;
  display:flex;
  height:100vh;
  background:#222;
  color:#fff;
  font-family:sans-serif;
}
#canvasWrap{
  flex:1;
  display:flex;
  justify-content:center;
  align-items:center;
  background:#000;
}
canvas{
  background:#555;
  touch-action:none;
}
#panel{
  width:420px;
  padding:10px;
  background:#333;
  overflow:auto;
}
.layer-item{
  background:#444;
  padding:4px;
  margin-bottom:4px;
  font-size:11px;
  cursor:pointer;
}
.layer-item.active{ background:#666; }
label{ font-size:12px; display:block; margin-top:6px; }
input,button{ width:100%; }
#logBox{
  background:#111;
  font-size:11px;
  padding:6px;
  white-space:pre-wrap;
  max-height:200px;
  overflow:auto;
}
</style>
</head>

<body>

<div id="canvasWrap">
  <canvas id="canvas"></canvas>
</div>

<div id="panel">
  <label>画像追加 <input type="file" id="imgInput"></label>

  <div id="layerList"></div>

  <h3>数値調整（安全）</h3>
  <label>X <input type="number" id="xI"></label>
  <label>Y <input type="number" id="yI"></label>
  <label>Scale <input type="number" step="0.01" id="sI"></label>
  <label>Rotate <input type="number" id="rI"></label>
  <label>Float（0〜10） <input type="number" min="0" max="10" id="fI"></label>
  <label>Speed（1〜10） <input type="number" min="1" max="10" id="spI"></label>

  <button id="snapshotBtn">スナップショット保存</button>
  <div id="logBox"></div>
</div>

<script>
/* ===== 基本 ===== */
const BASE_W=1280, BASE_H=720;
const FLOAT_PX=4, SPEED_UNIT=0.8;

const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const wrap=document.getElementById("canvasWrap");

/* ===== resize ===== */
function resize(){
  const r=wrap.getBoundingClientRect();
  const sc=Math.min(r.width/BASE_W,r.height/BASE_H);
  canvas.width=BASE_W*sc;
  canvas.height=BASE_H*sc;
  ctx.setTransform(sc,0,0,sc,0,0);
}
window.addEventListener("resize",resize);
resize();

/* ===== 状態 ===== */
let layers=[];
let current=null;

/* ===== UI参照 ===== */
const listEl=document.getElementById("layerList");
const xI=document.getElementById("xI");
const yI=document.getElementById("yI");
const sI=document.getElementById("sI");
const rI=document.getElementById("rI");
const fI=document.getElementById("fI");
const spI=document.getElementById("spI");
const logBox=document.getElementById("logBox");

/* ===== 画像追加 ===== */
imgInput.onchange=e=>{
  const f=e.target.files[0];
  const img=new Image();
  img.onload=()=>{
    const l={name:f.name,img,x:BASE_W/2,y:BASE_H/2,scale:1,rotate:0,float:0,speed:5};
    layers.unshift(l);
    setCurrent(l);
  };
  img.src=URL.createObjectURL(f);
};

/* ===== レイヤーUI ===== */
function renderLayerList(){
  listEl.innerHTML="";
  layers.forEach((l,i)=>{
    const d=document.createElement("div");
    d.className="layer-item"+(l===current?" active":"");
    d.textContent=`${i+1} ${l.name}`;
    d.onclick=()=>setCurrent(l);
    listEl.appendChild(d);
  });
}

function setCurrent(layer){
  current=layer;
  renderLayerList();
  updateInputsFromLayer();
}

/* ===== UI ← 状態（表示のみ） ===== */
function updateInputsFromLayer(){
  if(!current) return;
  xI.value=current.x;
  yI.value=current.y;
  sI.value=current.scale;
  rI.value=current.rotate;
  fI.value=current.float;
  spI.value=current.speed;
}

/* ===== UI → 状態（安全） ===== */
xI.oninput=()=>current && (current.x=+xI.value);
yI.oninput=()=>current && (current.y=+yI.value);
sI.oninput=()=>current && (current.scale=+sI.value);
rI.oninput=()=>current && (current.rotate=+rI.value);
fI.oninput=()=>current && (current.float=+fI.value);
spI.oninput=()=>current && (current.speed=+spI.value);

/* ===== タッチ操作 ===== */
let pointers=new Map();
let gesture=null;

canvas.addEventListener("pointerdown",e=>{
  canvas.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(pointers.size===2 && current){
    const p=[...pointers.values()];
    const dx=p[1].x-p[0].x, dy=p[1].y-p[0].y;
    gesture={
      dist:Math.hypot(dx,dy),
      angle:Math.atan2(dy,dx),
      scale:current.scale,
      rotate:current.rotate
    };
  }
});

canvas.addEventListener("pointerup",e=>{
  pointers.delete(e.pointerId);
  if(pointers.size<2) gesture=null;
});

canvas.addEventListener("pointermove",e=>{
  if(!current||!pointers.has(e.pointerId)) return;
  const prev=pointers.get(e.pointerId);
  pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
  const rect=canvas.getBoundingClientRect();

  if(pointers.size===1){
    current.x+=(e.clientX-prev.x)*BASE_W/rect.width;
    current.y+=(e.clientY-prev.y)*BASE_H/rect.height;
    updateInputsFromLayer();
  }

  if(pointers.size===2 && gesture){
    const p=[...pointers.values()];
    const dx=p[1].x-p[0].x, dy=p[1].y-p[0].y;
    current.scale=gesture.scale*(Math.hypot(dx,dy)/gesture.dist);
    current.rotate=gesture.rotate+(Math.atan2(dy,dx)-gesture.angle)*180/Math.PI;
    updateInputsFromLayer();
  }
});

/* ===== 描画 ===== */
let start=performance.now();
function draw(){
  const t=(performance.now()-start)/1000;
  ctx.fillStyle="#555";
  ctx.fillRect(0,0,BASE_W,BASE_H);
  layers.slice().reverse().forEach(l=>{
    if(!l.img.complete) return;
    const fy=Math.sin(t*l.speed*SPEED_UNIT)*l.float*FLOAT_PX;
    ctx.save();
    ctx.translate(l.x,l.y+fy);
    ctx.rotate(l.rotate*Math.PI/180);
    ctx.scale(l.scale,l.scale);
    ctx.drawImage(l.img,-l.img.width/2,-l.img.height/2);
    ctx.restore();
  });
  requestAnimationFrame(draw);
}
draw();

/* ===== ログ ===== */
snapshotBtn.onclick=()=>{
  let txt="SNAPSHOT\n";
  layers.forEach((l,i)=>{
    txt+=`${i+1} ${l.name} x:${l.x} y:${l.y} s:${l.scale} r:${l.rotate} f:${l.float} sp:${l.speed}\n`;
  });
  logBox.prepend(Object.assign(document.createElement("div"),{textContent:txt}));
};
</script>

</body>
</html>
