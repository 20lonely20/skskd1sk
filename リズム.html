
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>My Rhythm Game</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background: #0b0b12; color: #fff;
      font-family: system-ui, -apple-system, sans-serif;
      overscroll-behavior: none;
      touch-action: none; /* é‡è¦ï¼šãƒ–ãƒ©ã‚¦ã‚¶å´ã®ã‚¸ã‚§ã‚¹ãƒãƒ£ã‚’æŠ‘ãˆã‚‹ */
    }
    #app {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 8px;
      padding: 10px 14px; /* ç«¯ã‚¹ãƒ¯ã‚¤ãƒ—å¯¾ç­–ï¼šä½™ç™½ã‚’åšã‚ã« */
      box-sizing: border-box;
    }
    #topbar {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      font-size: 14px;
    }
    input, button {
      font-size: 14px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: #fff;
    }
    button { cursor: pointer; }
    button.primary { background: #7c3aed; border-color: #7c3aed; }
    button.danger { background: #ef4444; border-color: #ef4444; }

    #stage {
      position: relative;
      border-radius: 16px;
      background: radial-gradient(1200px 700px at 50% 30%, rgba(124,58,237,.22), rgba(0,0,0,0)) , #080810;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,.10);
    }

    /* ãƒ¬ãƒ¼ãƒ³ */
    .lanes {
      position: absolute; inset: 0;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      padding: 18px 18px; /* ç«¯ã‚¹ãƒ¯ã‚¤ãƒ—å¯¾ç­–ï¼šå†…å´ã«å¯„ã›ã‚‹ */
      box-sizing: border-box;
    }
    .lane {
      position: relative;
      border-radius: 14px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      overflow: hidden;
    }

    /* åˆ¤å®šãƒ©ã‚¤ãƒ³ï¼ˆä¸‹å´ï¼‰ */
    .judgeLine {
      position: absolute;
      left: 18px; right: 18px;
      bottom: 78px; /* ã‚¿ãƒƒãƒ—â­•ã®å°‘ã—ä¸Š */
      height: 2px;
      background: rgba(255,255,255,.22);
      border-radius: 999px;
    }

    /* ã‚¿ãƒƒãƒ—ã‚¨ãƒªã‚¢ï¼ˆâ­•ï¼‰ */
    .pads {
      position: absolute;
      left: 18px; right: 18px;
      bottom: 18px;
      height: 56px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      align-items: center;
    }
    .pad {
      height: 56px;
      border-radius: 14px;
      display: grid;
      place-items: center;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.12);
      user-select: none;
      -webkit-user-select: none;
    }
    .pad span { font-size: 24px; opacity: .95; }
    .pad:active { transform: scale(0.98); background: rgba(124,58,237,.25); }

    /* ãƒãƒ¼ãƒ„ï¼ˆğŸ’–ï¼‰ */
    .note {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      font-size: 26px;
      will-change: transform, top;
      pointer-events: none;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.45));
    }

    #hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      font-size: 14px;
      opacity: .95;
    }
    #judgement {
      font-weight: 800;
      font-size: 18px;
      min-width: 120px;
      text-align: right;
    }

    #logBox {
      max-height: 140px;
      overflow: auto;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      white-space: pre;
    }
  </style>
</head>
<body>
<div id="app">
  <div id="topbar">
    <input id="audioFile" type="file" accept="audio/*" />
    <span id="durationLabel">æ›²: æœªèª­ã¿è¾¼ã¿</span>
    <button id="initAudio" class="primary">éŸ³å£°åˆæœŸåŒ–ï¼ˆã‚¿ãƒƒãƒ—å¿…é ˆï¼‰</button>
    <button id="playBtn">å†ç”Ÿ</button>
    <button id="stopBtn">åœæ­¢</button>
    <button id="modeBtn">ãƒ¢ãƒ¼ãƒ‰: PLAY</button>
    <button id="exportBtn">è­œé¢ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
    <input id="importFile" type="file" accept="application/json" />
  </div>

  <div id="stage">
    <div class="lanes" id="lanes"></div>
    <div class="judgeLine"></div>
    <div class="pads" id="pads"></div>
  </div>

  <div id="hud">
    <div>
      <div>Perfect: <span id="pCount">0</span> / Good: <span id="gCount">0</span> / Miss: <span id="mCount">0</span></div>
      <div>ã‚ªãƒ•ã‚»ãƒƒãƒˆ(ms): <input id="offsetMs" type="number" value="0" style="width:90px; padding:8px 10px;" /></div>
    </div>
    <div id="judgement">READY</div>
  </div>

  <div id="logBox"></div>
</div>

<script>
(() => {
  // ========= è¨­å®š =========
  const LANE_COUNT = 5;
  const NOTE_TRAVEL_SEC = 1.3;   // ä¸Šã‹ã‚‰åˆ¤å®šãƒ©ã‚¤ãƒ³ã¾ã§è½ã¡ã‚‹æ™‚é–“ï¼ˆè¦‹ãŸç›®ï¼‰
  const PERFECT_MS = 35;         // iOS Safariæƒ³å®šã§ã¾ãšã¯å³ã—ã™ããªã„å€¤ã«
  const GOOD_MS = 90;
  const MISS_MS = 140;           // ã“ã®ç¯„å›²ã‚’è¶…ãˆãŸã‚‰Missæ‰±ã„ï¼ˆè‡ªå‹•Misså«ã‚€ï¼‰
  const HIT_Y_FROM_BOTTOM = 78 + 2; // judgeLineã®ä½ç½®ã«åˆã‚ã›ã‚‹ï¼ˆæ¦‚ç®—ï¼‰

  // ========= DOM =========
  const lanesEl = document.getElementById('lanes');
  const padsEl = document.getElementById('pads');
  const logEl = document.getElementById('logBox');
  const durationLabel = document.getElementById('durationLabel');
  const judgementEl = document.getElementById('judgement');

  const initAudioBtn = document.getElementById('initAudio');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const modeBtn = document.getElementById('modeBtn');

  const exportBtn = document.getElementById('exportBtn');
  const importFile = document.getElementById('importFile');
  const audioFile = document.getElementById('audioFile');
  const offsetMsInput = document.getElementById('offsetMs');

  const pCountEl = document.getElementById('pCount');
  const gCountEl = document.getElementById('gCount');
  const mCountEl = document.getElementById('mCount');

  // ========= ç”Ÿæˆ =========
  const laneEls = [];
  for (let i = 0; i < LANE_COUNT; i++) {
    const lane = document.createElement('div');
    lane.className = 'lane';
    lanesEl.appendChild(lane);
    laneEls.push(lane);

    const pad = document.createElement('div');
    pad.className = 'pad';
    pad.dataset.lane = String(i);
    pad.innerHTML = `<span>â­•</span>`;
    padsEl.appendChild(pad);
  }

  // ========= éŸ³å£° =========
  /** @type {AudioContext|null} */
  let audioCtx = null;
  /** @type {AudioBuffer|null} */
  let audioBuffer = null;
  /** @type {AudioBufferSourceNode|null} */
  let sourceNode = null;

  let isReady = false;
  let isPlaying = false;

  let startCtxTime = 0;     // audioCtx.currentTime at start
  let startSongTime = 0;    // seconds in song when start (for pause/resumeæ‹¡å¼µç”¨)

  // ========= è­œé¢ =========
  // note: { id, lane, time, hit:false, judged:false }
  /** @type {{id:string, lane:number, time:number, hit:boolean, judged:boolean}[]} */
  let chart = [];

  // åˆæœŸã®ä»®è­œé¢ï¼ˆã‚ã¨ã§æ¶ˆã—ã¦OKï¼‰
  chart = [
    {id: crypto.randomUUID(), lane:0, time:1.0, hit:false, judged:false},
    {id: crypto.randomUUID(), lane:1, time:1.3, hit:false, judged:false},
    {id: crypto.randomUUID(), lane:2, time:1.6, hit:false, judged:false},
    {id: crypto.randomUUID(), lane:3, time:1.9, hit:false, judged:false},
    {id: crypto.randomUUID(), lane:4, time:2.2, hit:false, judged:false},
  ];

  // ========= ãƒ­ã‚° =========
  const tapLog = []; // {tSong, lane, deltaMs, result, mode, noteId?}
  function log(line) {
    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ========= ãƒ¢ãƒ¼ãƒ‰ =========
  // PLAY: åˆ¤å®š
  // EDIT: è¿‘ã„ãƒãƒ¼ãƒ„å‰Šé™¤ or è¿½åŠ ï¼ˆã‚¿ãƒƒãƒ—æ™‚åˆ»ã«è¿½åŠ ï¼‰
  let mode = 'PLAY';
  function setMode(next) {
    mode = next;
    modeBtn.textContent = `ãƒ¢ãƒ¼ãƒ‰: ${mode}`;
    judgementEl.textContent = (mode === 'PLAY') ? 'PLAY' : 'EDIT';
  }

  // ========= ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =========
  function fmtDuration(sec) {
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return `${m}åˆ†${String(s).padStart(2,'0')}ç§’`;
  }

  function songTimeNow() {
    if (!isPlaying || !audioCtx) return 0;
    const t = (audioCtx.currentTime - startCtxTime) + startSongTime;
    const offsetSec = (Number(offsetMsInput.value || 0) / 1000);
    return t + offsetSec;
  }

  function resetJudgeCounts() {
    pCountEl.textContent = '0';
    gCountEl.textContent = '0';
    mCountEl.textContent = '0';
  }

  function addCount(kind) {
    if (kind === 'PERFECT') pCountEl.textContent = String(Number(pCountEl.textContent)+1);
    if (kind === 'GOOD') gCountEl.textContent = String(Number(gCountEl.textContent)+1);
    if (kind === 'MISS') mCountEl.textContent = String(Number(mCountEl.textContent)+1);
  }

  function showJudge(text) {
    judgementEl.textContent = text;
  }

  // ========= Audio åˆæœŸåŒ– =========
  initAudioBtn.addEventListener('click', async () => {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
    }
    if (audioCtx.state !== 'running') {
      await audioCtx.resume();
    }
    showJudge('AUDIO OK');
  });

  // ========= æ›²ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ â†’ é•·ã•è¡¨ç¤º =========
  audioFile.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // AudioContextã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§resumeãŒå¿…è¦ãªã®ã§ã€ã“ã“ã§æœªåˆæœŸåŒ–ãªã‚‰ä½œã‚‹ãŒã€initãƒœã‚¿ãƒ³ã‚‚æ®‹ã™
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });

    const arrayBuf = await file.arrayBuffer();
    audioBuffer = await audioCtx.decodeAudioData(arrayBuf.slice(0));
    durationLabel.textContent = `æ›²: ${fmtDuration(audioBuffer.duration)}`;
    isReady = true;
    log(`[LOAD] duration=${audioBuffer.duration.toFixed(3)}s`);
  });

  // ========= å†ç”Ÿ/åœæ­¢ =========
  playBtn.addEventListener('click', async () => {
    if (!audioCtx || !audioBuffer) { showJudge('æ›²ã‚’èª­ã¿è¾¼ã‚“ã§'); return; }
    if (audioCtx.state !== 'running') await audioCtx.resume();
    if (isPlaying) return;

    // reset
    for (const n of chart) { n.hit = false; n.judged = false; }
    resetJudgeCounts();
    showJudge('START');

    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = audioBuffer;
    sourceNode.connect(audioCtx.destination);

    startSongTime = 0;
    startCtxTime = audioCtx.currentTime;
    isPlaying = true;

    sourceNode.start(0, startSongTime);

    sourceNode.onended = () => {
      isPlaying = false;
      sourceNode = null;
      showJudge('END');
    };
  });

  stopBtn.addEventListener('click', () => {
    if (!isPlaying) return;
    try { sourceNode?.stop(); } catch {}
    isPlaying = false;
    sourceNode = null;
    showJudge('STOP');
  });

  // ========= ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ =========
  modeBtn.addEventListener('click', () => setMode(mode === 'PLAY' ? 'EDIT' : 'PLAY'));

  // ========= å…¥åŠ›ï¼ˆã‚¿ãƒƒãƒ—ï¼‰ =========
  // iOS Safari: passive:false + preventDefault ãŒé‡è¦
  function onPadPress(lane) {
    const t = songTimeNow();

    if (mode === 'EDIT') {
      // è¿‘ã„ãƒãƒ¼ãƒ„ãŒã‚ã‚Œã°å‰Šé™¤ã€ãªã‘ã‚Œã°è¿½åŠ 
      const nearest = findNearestNote(lane, t, 0.12); // 120msä»¥å†…ãªã‚‰å‰Šé™¤å¯¾è±¡
      if (nearest) {
        chart = chart.filter(n => n.id !== nearest.id);
        log(`[EDIT] REMOVE lane=${lane} t=${nearest.time.toFixed(3)} id=${nearest.id}`);
        showJudge('REMOVE');
      } else {
        const note = { id: crypto.randomUUID(), lane, time: t, hit:false, judged:false };
        chart.push(note);
        chart.sort((a,b)=>a.time-b.time);
        log(`[EDIT] ADD lane=${lane} t=${t.toFixed(3)} id=${note.id}`);
        showJudge('ADD');
      }
      return;
    }

    // PLAYåˆ¤å®š
    const hit = judgeHit(lane, t);
    if (!hit) {
      tapLog.push({ tSong:t, lane, deltaMs:null, result:'MISS', mode, noteId:null });
      log(`[TAP] lane=${lane} t=${t.toFixed(3)} -> MISS(no note)`);
      showJudge('MISS');
      addCount('MISS');
    }
  }

  function attachPadHandlers(el) {
    el.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      const lane = Number(el.dataset.lane);
      onPadPress(lane);
    }, { passive: false });
  }
  [...padsEl.children].forEach(attachPadHandlers);

  // ç”»é¢å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«/ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ æŠ‘æ­¢ï¼ˆiOSå¯¾ç­–ï¼‰
  document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
  document.addEventListener('gesturestart', (e) => e.preventDefault(), { passive: false });

  // ========= åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ =========
  function findNearestNote(lane, tSong, withinSec) {
    let best = null;
    let bestAbs = Infinity;
    for (const n of chart) {
      if (n.lane !== lane) continue;
      if (n.judged) continue;
      const d = n.time - tSong;
      const ad = Math.abs(d);
      if (ad < bestAbs) { bestAbs = ad; best = n; }
    }
    if (best && bestAbs <= withinSec) return best;
    return null;
  }

  function judgeHit(lane, tSong) {
    const n = findNearestNote(lane, tSong, MISS_MS/1000);
    if (!n) return null;

    const deltaMs = (tSong - n.time) * 1000; // +é…ã„ / -æ—©ã„
    const ad = Math.abs(deltaMs);

    let result = 'MISS';
    if (ad <= PERFECT_MS) result = 'PERFECT';
    else if (ad <= GOOD_MS) result = 'GOOD';
    else if (ad <= MISS_MS) result = 'MISS';

    n.judged = true;
    n.hit = (result !== 'MISS');

    tapLog.push({ tSong, lane, deltaMs, result, mode, noteId:n.id });
    log(`[TAP] lane=${lane} t=${tSong.toFixed(3)} note=${n.time.toFixed(3)} d=${deltaMs.toFixed(1)}ms -> ${result}`);
    showJudge(result);
    addCount(result);
    return { note:n, result, deltaMs };
  }

  // è‡ªå‹•MISSï¼ˆåˆ¤å®šãƒ©ã‚¤ãƒ³ã‚’éããŸã‚‰ï¼‰
  function autoMissSweep(tSong) {
    const missAfter = MISS_MS/1000;
    for (const n of chart) {
      if (n.judged) continue;
      if (tSong - n.time > missAfter) {
        n.judged = true;
        n.hit = false;
        addCount('MISS');
        log(`[AUTO] MISS lane=${n.lane} note=${n.time.toFixed(3)}`);
      }
    }
  }

  // ========= æç”» =========
  const noteEls = new Map(); // id -> element

  function ensureNoteEl(note) {
    let el = noteEls.get(note.id);
    if (!el) {
      el = document.createElement('div');
      el.className = 'note';
      el.textContent = 'ğŸ’–';
      laneEls[note.lane].appendChild(el);
      noteEls.set(note.id, el);
    }
    return el;
  }

  function cleanupOrphans() {
    for (const [id, el] of noteEls.entries()) {
      if (!chart.some(n => n.id === id)) {
        el.remove();
        noteEls.delete(id);
      }
    }
  }

  function render() {
    const stageRect = document.getElementById('stage').getBoundingClientRect();
    const laneRect = laneEls[0].getBoundingClientRect();
    const laneH = laneRect.height;

    const tSong = songTimeNow();
    if (isPlaying) autoMissSweep(tSong);

    cleanupOrphans();

    for (const n of chart) {
      // ã™ã§ã«åˆ¤å®šæ¸ˆã¿ã§ã€ç”»é¢å¤–ãªã‚‰æ¶ˆã™ï¼ˆä»»æ„ï¼‰
      const dt = n.time - tSong; // ãƒãƒ¼ãƒ„æ™‚åˆ»ã¾ã§æ®‹ã‚Š
      const el = ensureNoteEl(n);

      // ç”»é¢ä¸Šéƒ¨ã‚’ -travelã€åˆ¤å®šç·šã‚’ travel=0 ã«ã—ãŸã„
      // dt=NOTE_TRAVEL_SEC ã®æ™‚: top=0ä»˜è¿‘ã€dt=0ã®æ™‚: judge lineä»˜è¿‘
      const progress = 1 - (dt / NOTE_TRAVEL_SEC); // dt=NOTE_TRAVEL -> 0, dt=0 -> 1
      const clamped = Math.max(-0.2, Math.min(1.6, progress));

      // laneå†… top ã‚’è¨ˆç®—ï¼ˆä¸‹ã‹ã‚‰HIT_Y_FROM_BOTTOMã®ä½ç½®ã«åˆ¤å®šç·šãŒã‚ã‚‹æƒ³å®šï¼‰
      const hitY = laneH - HIT_Y_FROM_BOTTOM;
      const y = hitY * clamped;

      el.style.top = `${y}px`;
      el.style.opacity = n.judged ? '0.25' : '1.0';

      // ç”»é¢å¤–ï¼†åˆ¤å®šæ¸ˆã¿ã¯éè¡¨ç¤º
      if (clamped > 1.35 && n.judged) el.style.display = 'none';
      else el.style.display = 'block';
    }

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // ========= ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ =========
  exportBtn.addEventListener('click', () => {
    const data = {
      version: 1,
      laneCount: LANE_COUNT,
      chart: chart.map(n => ({ lane:n.lane, time:Number(n.time.toFixed(5)) })),
      taps: tapLog,
      settings: { NOTE_TRAVEL_SEC, PERFECT_MS, GOOD_MS, MISS_MS }
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'chart.json';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  importFile.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const txt = await file.text();
    const json = JSON.parse(txt);
    if (!json.chart || !Array.isArray(json.chart)) { showJudge('ä¸æ­£ãªJSON'); return; }
    chart = json.chart.map(x => ({ id: crypto.randomUUID(), lane:x.lane, time:x.time, hit:false, judged:false }))
                     .sort((a,b)=>a.time-b.time);
    log(`[IMPORT] notes=${chart.length}`);
    showJudge('IMPORTED');
  });

  // åˆæœŸãƒ¢ãƒ¼ãƒ‰
  setMode('PLAY');
  log('READY. 1) æ›²ã‚’é¸ã¶ 2) éŸ³å£°åˆæœŸåŒ– 3) å†ç”Ÿ');
})();
</script>
</body>
</html>
